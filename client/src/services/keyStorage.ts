// Key storage service - loads keys from localStorage and provides access
// Keys are generated by the worker and stored in localStorage

import Tfhe, { 
    Boolean,
    BooleanPublicKey,
    BooleanCompressedServerKey,
    BooleanClientKey
} from "../tfhe/tfhe"

// ---------- Helper functions for serialization ----------
function arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

function uint8ArrayToBase64(arr: Uint8Array): string {
    let binary = '';
    for (let i = 0; i < arr.length; i++) {
        binary += String.fromCharCode(arr[i]);
    }
    return btoa(binary);
}

// ---------- Password â†’ AES-GCM key derivation ----------
async function deriveAESKey(
    password: string,
    salt: Uint8Array
): Promise<CryptoKey> {
    const baseKey = await crypto.subtle.importKey(
        "raw",
        new TextEncoder().encode(password),
        "PBKDF2",
        false,
        ["deriveKey"]
    );

    return crypto.subtle.deriveKey(
        {
            name: "PBKDF2",
            salt: salt as BufferSource,
            iterations: 200_000,
            hash: "SHA-256",
        },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
    );
}

// ---------- Key Storage Interface ----------
export interface StoredKeys {
    ed25519: {
        pk: string;
        sk_encrypted: string;
        salt: string;
        iv: string;
    };
    x25519: {
        pk: string;
        sk_encrypted: string;
        salt: string;
        iv: string;
    };
    fhe_sk: string;
}

// ---------- Store keys in localStorage from Map ----------
export function storeKeys(keys: StoredKeys): void {
    if (typeof localStorage === 'undefined') {
        throw new Error('localStorage is not available');
    }

    // Store Ed25519 keys
    localStorage.setItem('ed25519_pk', keys.ed25519.pk);
    localStorage.setItem('ed25519_sk_encrypted', keys.ed25519.sk_encrypted);
    localStorage.setItem('ed25519_salt', keys.ed25519.salt);
    localStorage.setItem('ed25519_iv', keys.ed25519.iv);

    // Store X25519 keys
    localStorage.setItem('x25519_pk', keys.x25519.pk);
    localStorage.setItem('x25519_sk_encrypted', keys.x25519.sk_encrypted);
    localStorage.setItem('x25519_salt', keys.x25519.salt);
    localStorage.setItem('x25519_iv', keys.x25519.iv);

    // Store FHE private key
    localStorage.setItem('fhe_sk', keys.fhe_sk);
}

// ---------- Retrieve keys from localStorage as Map ----------
export function retrieveKeys(): StoredKeys | null {
    if (typeof localStorage === 'undefined') {
        throw new Error('localStorage is not available');
    }

    const ed25519_pk = localStorage.getItem('ed25519_pk');
    const ed25519_sk_encrypted = localStorage.getItem('ed25519_sk_encrypted');
    const ed25519_salt = localStorage.getItem('ed25519_salt');
    const ed25519_iv = localStorage.getItem('ed25519_iv');

    const x25519_pk = localStorage.getItem('x25519_pk');
    const x25519_sk_encrypted = localStorage.getItem('x25519_sk_encrypted');
    const x25519_salt = localStorage.getItem('x25519_salt');
    const x25519_iv = localStorage.getItem('x25519_iv');

    const fhe_sk = localStorage.getItem('fhe_sk');

    // Check if all keys are present
    if (!ed25519_pk || !ed25519_sk_encrypted || !ed25519_salt || !ed25519_iv ||
        !x25519_pk || !x25519_sk_encrypted || !x25519_salt || !x25519_iv ||
        !fhe_sk) {
        return null;
    }

    return {
        ed25519: {
            pk: ed25519_pk,
            sk_encrypted: ed25519_sk_encrypted,
            salt: ed25519_salt,
            iv: ed25519_iv,
        },
        x25519: {
            pk: x25519_pk,
            sk_encrypted: x25519_sk_encrypted,
            salt: x25519_salt,
            iv: x25519_iv,
        },
        fhe_sk: fhe_sk,
    };
}

// Helper to convert base64 to Uint8Array
function base64ToUint8Array(base64: string): Uint8Array {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
}

// Helper to convert base64 to ArrayBuffer
function base64ToArrayBuffer(base64: string): ArrayBuffer {
    const uint8 = base64ToUint8Array(base64);
    // Create a new ArrayBuffer to avoid SharedArrayBuffer issues
    const buffer = new ArrayBuffer(uint8.length);
    new Uint8Array(buffer).set(uint8);
    return buffer;
}

// ---------- FHE Keys ----------
let fhe_pk: BooleanPublicKey | null = null;
let fhe_ek: BooleanCompressedServerKey | null = null;
let fhe_sk: BooleanClientKey | null = null;

// Load FHE keys from localStorage
export async function loadFHEKeys(): Promise<void> {
    if (typeof localStorage === 'undefined') {
        throw new Error('localStorage is not available');
    }

    const fhe_sk_base64 = localStorage.getItem('fhe_sk');
    if (!fhe_sk_base64) {
        throw new Error('FHE keys not found. Please complete onboarding first.');
    }

    // Load TFHE library if not already loaded
    await Tfhe();

    // Deserialize FHE private key
    const fhe_sk_bytes = base64ToUint8Array(fhe_sk_base64);
    fhe_sk = Boolean.deserialize_client_key(fhe_sk_bytes);

    // Generate public and evaluation keys from private key
    fhe_ek = Boolean.new_compressed_server_key(fhe_sk);
    fhe_pk = Boolean.new_public_key(fhe_sk);
}

// ---------- Messaging Keys (X25519) ----------
let msg_pk: CryptoKey | null = null;
let msg_sk: CryptoKey | null = null;

// Load messaging keys from localStorage
export async function loadMessagingKeys(userPassword: string): Promise<void> {
    if (typeof localStorage === 'undefined') {
        throw new Error('localStorage is not available');
    }

    const pk_base64 = localStorage.getItem('x25519_pk');
    const sk_encrypted_base64 = localStorage.getItem('x25519_sk_encrypted');
    const salt_base64 = localStorage.getItem('x25519_salt');
    const iv_base64 = localStorage.getItem('x25519_iv');

    if (!pk_base64 || !sk_encrypted_base64 || !salt_base64 || !iv_base64) {
        throw new Error('Messaging keys not found. Please complete onboarding first.');
    }

    // Import public key
    const publicKeyBytes = base64ToUint8Array(pk_base64);
    const publicKeyBuffer = new ArrayBuffer(publicKeyBytes.length);
    new Uint8Array(publicKeyBuffer).set(publicKeyBytes);
    msg_pk = await crypto.subtle.importKey(
        'raw',
        publicKeyBuffer,
        { name: 'X25519' },
        false,
        ['deriveKey', 'deriveBits']
    );

    // Decrypt and import private key
    const salt = base64ToUint8Array(salt_base64);
    const iv = base64ToUint8Array(iv_base64);
    const encryptedPrivateKey = base64ToArrayBuffer(sk_encrypted_base64);

    const aesKey = await deriveAESKey(userPassword, salt);
    const encryptedBuffer = new Uint8Array(encryptedPrivateKey);
    const encryptedArrayBuffer = new ArrayBuffer(encryptedBuffer.length);
    new Uint8Array(encryptedArrayBuffer).set(encryptedBuffer);
    const ivBuffer = new ArrayBuffer(iv.length);
    new Uint8Array(ivBuffer).set(iv);
    const decryptedPrivateKey = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: new Uint8Array(ivBuffer) },
        aesKey,
        encryptedArrayBuffer
    );

    const privateKeyBytes = new Uint8Array(decryptedPrivateKey);
    const privateKeyBuffer = new ArrayBuffer(privateKeyBytes.length);
    new Uint8Array(privateKeyBuffer).set(privateKeyBytes);
    msg_sk = await crypto.subtle.importKey(
        'raw',
        privateKeyBuffer,
        { name: 'X25519' },
        false,
        ['deriveKey', 'deriveBits']
    );
}

// Get messaging public key
export async function getMessagingPublicKey(): Promise<CryptoKey> {
    if (!msg_pk) {
        throw new Error('Messaging keys not loaded. Call loadMessagingKeys() first.');
    }
    return msg_pk;
}

// Get messaging private key
export async function getMessagingPrivateKey(): Promise<CryptoKey> {
    if (!msg_sk) {
        throw new Error('Messaging keys not loaded. Call loadMessagingKeys() first.');
    }
    return msg_sk;
}

// ---------- Identity Keys (Ed25519) ----------
let identity_pk: CryptoKey | null = null;
let identity_sk: CryptoKey | null = null;

// Load identity keys from localStorage
export async function loadIdentityKeys(userPassword: string): Promise<void> {
    if (typeof localStorage === 'undefined') {
        throw new Error('localStorage is not available');
    }

    const pk_base64 = localStorage.getItem('ed25519_pk');
    const sk_encrypted_base64 = localStorage.getItem('ed25519_sk_encrypted');
    const salt_base64 = localStorage.getItem('ed25519_salt');
    const iv_base64 = localStorage.getItem('ed25519_iv');

    if (!pk_base64 || !sk_encrypted_base64 || !salt_base64 || !iv_base64) {
        throw new Error('Identity keys not found. Please complete onboarding first.');
    }

    // Import public key
    const publicKeyBytes = base64ToUint8Array(pk_base64);
    const publicKeyBuffer = new ArrayBuffer(publicKeyBytes.length);
    new Uint8Array(publicKeyBuffer).set(publicKeyBytes);
    identity_pk = await crypto.subtle.importKey(
        'raw',
        publicKeyBuffer,
        { name: 'Ed25519' },
        false,
        ['verify']
    );

    // Decrypt and import private key
    const salt = base64ToUint8Array(salt_base64);
    const iv = base64ToUint8Array(iv_base64);
    const encryptedPrivateKey = base64ToArrayBuffer(sk_encrypted_base64);

    const aesKey = await deriveAESKey(userPassword, salt);
    const encryptedBuffer = new Uint8Array(encryptedPrivateKey);
    const encryptedArrayBuffer = new ArrayBuffer(encryptedBuffer.length);
    new Uint8Array(encryptedArrayBuffer).set(encryptedBuffer);
    const ivBuffer = new ArrayBuffer(iv.length);
    new Uint8Array(ivBuffer).set(iv);
    const decryptedPrivateKey = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: new Uint8Array(ivBuffer) },
        aesKey,
        encryptedArrayBuffer
    );

    const privateKeyBytes = new Uint8Array(decryptedPrivateKey);
    const privateKeyBuffer = new ArrayBuffer(privateKeyBytes.length);
    new Uint8Array(privateKeyBuffer).set(privateKeyBytes);
    identity_sk = await crypto.subtle.importKey(
        'raw',
        privateKeyBuffer,
        { name: 'Ed25519' },
        false,
        ['sign']
    );
}

// Get identity public key
export async function getIdentityPublicKey(): Promise<CryptoKey> {
    if (!identity_pk) {
        throw new Error('Identity keys not loaded. Call loadIdentityKeys() first.');
    }
    return identity_pk;
}

// Get identity private key
export async function getIdentityPrivateKey(): Promise<CryptoKey> {
    if (!identity_sk) {
        throw new Error('Identity keys not loaded. Call loadIdentityKeys() first.');
    }
    return identity_sk;
}

// ---------- FHE Encryption/Decryption Functions ----------

export async function fhe_encr(bit: boolean): Promise<Uint8Array> {
    if (!fhe_sk || !fhe_pk) {
        await loadFHEKeys();
    }
    if (!fhe_sk || !fhe_pk) {
        throw new Error('FHE keys not initialized');
    }
    return Boolean.serialize_ciphertext(Boolean.encrypt_with_public_key(fhe_pk, bit));
}

export async function fhe_decr(cipher: Uint8Array): Promise<boolean> {
    if (!fhe_sk) {
        await loadFHEKeys();
    }
    if (!fhe_sk) {
        throw new Error('FHE secret key not initialized');
    }
    return Boolean.decrypt(fhe_sk, Boolean.deserialize_ciphertext(cipher));
}

