// src/lib/stores/app.ts
import { writable, derived, get } from 'svelte/store';
import type {
  UserProfile, SearchProfile, ChatSession, Message, MatchProfile
} from '../types';
import {
  DEFAULT_USER_PROFILE,
  DEFAULT_SEARCH_PROFILES
} from '../constants';
import { getMatches as getMatchesApi } from '../services/matchApiService';

// --- state stores ---

export const firstVisit = writable(true);       // persist as you wish (todo: localStorage)
export const showOnboarding = writable(true);   // mirrored to firstVisit logic
export const appInstalled = writable(false);

export const userProfile = writable<UserProfile>({ ...DEFAULT_USER_PROFILE });
export const searchProfiles = writable<SearchProfile[]>(JSON.parse(JSON.stringify(DEFAULT_SEARCH_PROFILES)));
export const sessions = writable<ChatSession[]>([]);
export const activeChatId = writable<string | null>(null);
export const isEditingUser = writable(false);
export const editingSearchId = writable<string | null>(null);

// derived
export const activeSession = derived([sessions, activeChatId], ([$sessions, $activeChatId]) =>
  $sessions.find(s => s.matchId === $activeChatId)
);

// userAvatar is deprecated - use Avatar component directly
// Keeping for backward compatibility but it returns empty string
export const userAvatar = derived(userProfile, $u => '');

// --- actions ---
export async function refreshMatches() {
  const up = get(userProfile);
  const curSessions = [...get(sessions)];

  try {
    // Get matches from backend
    const response = await getMatchesApi({
      phone: (up as any).phone || '',
      age: up.age,
      gender: up.gender.toString(),
      department: up.department,
      interests: up.interests,
    });

    if (response.success) {
      // Process matches from backend
      for (const matchData of response.matches) {
        if (!curSessions.find(s => s.matchId === matchData.phone)) {
          // Create match profile from backend data
          // Private data (age, department, avatar) is stored client-side, not in DB
          // Avatar is now generated by Avatar component, no URL needed
          const match: MatchProfile = {
            id: matchData.phone,
            searchProfileId: matchData.match_id,
            searchProfileName: `Match ${matchData.phone}`,
            funWord: 'Nouveau',
            avatarUrl: '', // Not used anymore - Avatar component generates it
            age: 0, // Will be decrypted from client-side storage if needed
            gender: 'ANY' as any,
            department: '', // Will be decrypted from client-side storage if needed
            interests: [],
          };

          curSessions.push({
            matchId: matchData.phone,
            match,
            messages: [],
            unread: true
          });
        }
      }
    }
  } catch (error) {
    console.error('Error fetching matches from backend:', error);
  }

  curSessions.sort((a,b) => {
    const aTime = a.messages.length > 0 ? a.messages[a.messages.length-1].timestamp : 0;
    const bTime = b.messages.length > 0 ? b.messages[b.messages.length-1].timestamp : 0;
    return bTime - aTime;
  });
  sessions.set(curSessions);
}

export async function handleSendMessage(text: string, attachment?: any, destinationPhone?: string) {
  if (!text.trim() && !attachment) return;
  const curSessions = [...get(sessions)];
  const aid = destinationPhone || get(activeChatId);
  if (!aid) return;
  
  // Create session if it doesn't exist (for direct messaging)
  let idx = curSessions.findIndex(s => s.matchId === aid);
  if (idx === -1) {
    // Import and create session for this phone number
    const { createChatSession } = await import('../services/chatService');
    await createChatSession(aid);
    // Reload sessions
    const updatedSessions = [...get(sessions)];
    idx = updatedSessions.findIndex(s => s.matchId === aid);
    if (idx === -1) return; // Still not found, abort
    curSessions.push(updatedSessions[idx]);
  }

  const userMsg: Message = {
    id: Date.now().toString(),
    senderId: 'user',
    text: text || '',
    timestamp: Date.now(),
    attachment: attachment ? {
      id: attachment.id,
      type: attachment.type,
      fileName: attachment.fileName,
      mimeType: attachment.mimeType,
      size: attachment.size,
    } : undefined,
  };
  curSessions[idx].messages = [...curSessions[idx].messages, userMsg];
  sessions.set(curSessions);

  // TODO: Send encrypted message via secureMessagingService
  // For now, keep the AI response system
  // In production, this would:
  // 1. Encrypt message with destination's public key
  // 2. Send to backend
  // 3. Wait for response (or use WebSocket/polling)
  
  try {
    // Try to send encrypted message (if destination phone is available)
    const { sendEncryptedChatMessage } = await import('../services/secureMessagingService');
    const destinationPhone = curSessions[idx].match.id; // TODO: Get actual phone from match
    if (destinationPhone) {
      await sendEncryptedChatMessage(text, destinationPhone, aid);
    }
  } catch (error) {
    console.warn('Encrypted send failed, using fallback:', error);
  }

  // Messages are now handled by the backend - no mock AI responses
  sessions.set(curSessions);
}

export function createSearchProfile() {
  const newId = `sp_${Date.now()}`;
  const newProfile: SearchProfile = {
    id: newId,
    name: 'Nouveau',
    minAge: 18,
    maxAge: 99,
    gender: 'ANY',
    country: 'FR',
    departments: [get(userProfile).department],
    interests: [],
  };
  searchProfiles.update(s => [...s, newProfile]);
  editingSearchId.set(newId);
}

export function deleteSearchProfile(id: string) {
  searchProfiles.update(s => s.filter(p => p.id !== id));
  editingSearchId.set(null);
}
